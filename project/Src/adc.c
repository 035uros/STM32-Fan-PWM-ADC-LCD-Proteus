#include <stdio.h>
#include "stm32f103x6.h"

void delay(int num);																//декларација функције и њених параметара
uint8_t kopirajUString(char* buffer, char* str, int* pvrednost, int* pvrednost2);	//декларација функције и њених параметара
void LCD_WriteText(char* text);														//декларација функције и њених параметара
void UART_Send (uint8_t *buffer);													//декларација функције и њених параметара
void adtim1(void);																	//декларација функције и њених параметара

volatile int adc_dr;								//променљива за чување вредности АД конверзије
int adcstari;										//помоћна променљива за чување вредности АД конверзије
char buffer[32];									//бафер који користимо за USART комуникацију
char buffer2[32];								//бафер који користимо за LCD екран
int k=1;											//к представља флег који нам говори за је два пута дошло до прекида, тј. да је тајмер измерио 10 секунди
int temp;											//променљива за чување измерене температуре
int speed;											//променљива за чување измерене брзине у процентима

//општа иницијализација АД конвертора
void ADC_General_Init(ADC_TypeDef *  ADCx){

	ADCx->CR2 |= ADC_CR2_ADON;						//уписујемо 1 на бит 0 контролног регистра 2 АД конвертора и тако укључујемо ADC, стр. 243
	delay(20);										//осигуравамо се да је АД конвертор имао довољно времена да се укључи

	ADCx->CR2 |= ADC_CR2_CAL;						//укључујемо калибрацију уписивањем 1 на бит 2, бит се аутоматски брише након калибрације, стр. 243
	while((ADCx->CR2 & ADC_CR2_CAL)==ADC_CR2_CAL);  //чекамо извршење калибрације

	ADCx->CR2 &= ~ADC_CR2_ADON;						//искључујемо конвертор док не подесимо све параметре

	ADCx->CR2 &= ~ADC_CR2_CONT; 					//уписујемо 0 у бит 1 и тиме сетујемо Single conversion mode, стр. 243

	ADCx->CR2 |= ADC_CR2_TSVREFE;					//укључујемо интерни темп. сензор и референти напон, стр. 242

	ADCx->SQR1 &= ~ADC_SQR1_L;   					//уписивањем 0 на битове L[3:0] у ADC_SQR1 сетујемо 1 конверзију, стр. 247

	ADCx->SQR3 &= ~ADC_SQR3_SQ1; 					//бришемо поље SQ1[4:0] до би одабрали канал 1 за прву и једину конверзију у регуларној групи

	ADCx->SQR3 |= (1U << ADC_SQR3_SQ1_Pos); 		// ADC_SQR3_SQ1_Pos означава позицију SQ1 у регистру ADC_SQR3. SQ1 = Channel 1, стр. 249

	ADCx->CR2 &= ~ADC_CR2_EXTSEL;					//бришемо поље EXTSEL контролонг регистра 2

	ADCx->CR2 |= (0b100U << ADC_CR2_EXTSEL_Pos); 	//уписујемо 100 у битове L[2:0], тиме сетујемо Timer 3 TRGO event, стр. 241

	ADC1->CR2 |= ADC_CR2_EXTTRIG; 				//омогућујемо окидање конверзије од стране спољних окидача, стр. 241

	ADCx->CR2 |= ADC_CR2_ADON;						//укључујемо конвертор након подешавања
}

//функција за иницијализацију пинова које ће АД конвертор користити
void ADC_GPIO_Init(void) {

	RCC->APB2ENR |=   RCC_APB2ENR_IOPAEN; 			//омогућавамо клок порта А уписивањем 1 на бит 2 APB2ENR регистра, стр. 114

	//са стране 26 у STM32F103_Datasheet видимо да се користи пин PA1, са стране 169 видимо да је пин потребно конфигурисати као Аналог
	GPIOA->CRL &= ~(GPIO_CRL_MODE1 | GPIO_CRL_CNF1); //брисањем ових битова добијамо MODE1[1:0]=00:Input, CNF1[1:0]=00:Analog, што нам је и потребно
}

//функција за иницијализацију АД конвертора
void ADC_Init(void) {

	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;  			//омогућавамо клок ADC 1, стр. 114

	ADC_GPIO_Init();								//позивамо иницијализацију пина

	ADC_General_Init(ADC1);							//шаљемо који ћемо АД конвертор користити функцији за општу иницијализацију

	ADC1->CR1 |= ADC_CR1_EOCIE; 					//уписивањем 1 у бит EOCIE омогућавамо прекид, стр. 240

	NVIC_SetPriority(ADC1_IRQn, 1);					//постављање приоритета прекида

	NVIC_EnableIRQ(ADC1_2_IRQn); 					//омогућавање прекида

	adtim1();										//иницијализација тајмера за окидање конверзија
}

//функција која прихвата прекид АД конвертора
void ADC1_2_IRQHandler(void) {

	uint16_t statReg = (ADC1->SR & 0xFFFFU);		//променљива у коју уписујемо стање у статусном регистру АД конвертора, стр. 237

	if ((statReg & ADC_SR_EOC) == ADC_SR_EOC) {		//преоверавамо да ли је конверзија завршена, тј. EOC бит сетован, стр. 237

		adc_dr = (ADC1->DR & 0xFFFFU);				//уколико јесте, чувамо резултат конверзије у променљиву

		if(adc_dr != adcstari){						//проверавамо да ли је дошло до промене температуре у односу на претходно стање
			if(adc_dr <=149){						//149 нам представља доњу границу, тј. 18 степени, уколико дође до те или испод те температуре мотор се зауставља
				if (!((GPIOA->IDR >> 4) & 1)) TIM2->CCR4 = 999;	//уколико је уређај у аутоматском режиму рада мењамо вредност CCR4 односно duty cycle
			}
			else if( adc_dr >= 288){				//288 нам представља горњу границу, тј. 35 степени, уколико дође до те или преко те температуре мотор ради максималном брзином
				if (!((GPIOA->IDR >> 4) & 1)) TIM2->CCR4 = 0;   //уколико је уређај у аутоматском режиму рада мењамо вредност CCR4 односно duty cycle
			}
			else{
				if (!((GPIOA->IDR >> 4) & 1)) TIM2->CCR4 = (int)999-(adc_dr-149)*7,18; //уколико је темп. између 18 и 35 степени, на основу АД конверзије и стартнe вредност ARR израчунавамо коју вредност да упишемо у CCR4
			}

		//до граничних вредности се стигло очитавањем АД конверзије за унапред познату темп, тј. 18 и 35 степени
		//18		35 		степени, разлика 17
		//149		288		очитана вредност, разлика 139
		//999		0		опсег ARR, разлика -999
		//					999/139~7,18 -> коефицијент за претварање вредности АД конверзије у CCR4 вредност

		adcstari=adc_dr;							//чувамо тренутну вредност АД конверзије како не бисмо пролазили поново кроз цели поступак уколико до промене температуре не дође
		}
	}
	TIM3->SR &= ~TIM_SR_TIF;						//бришемо тригер флег за прекид из статусног регистра тајмера 3, стр. 410
}

//функција која прихвата update прекид тајмера 1
void TIM1_UP_IRQHandler(void){

	temp=adcstari/8,288571429; 			//претварање вредности АД конверзије у степене целзијуса, коефицијент добијен формулом c=adc/temp
	if(temp > 30) temp--;				//коефицијент није најпрецизнији, за темп. преко 29 степени приказује степен више, то лако решавамо
	speed=100-(TIM2->CCR4*100)/999;		//рачунање брзине у процентима
	k++;								//5 секунди је прошло

	kopirajUString((char *)buffer2, "T=%dC | V=%d/% ", &temp, &speed); //копирамо текст у бафер
	LCD_WriteText((char *)buffer2);	//исписујемо текст на LCD екран

	if(k % 2 == 0 /*&& k != 2*/){			//уколико је прошло 10 сек
		//k=0;							//ресетовање флега
		kopirajUString((char *)buffer, "Temperatura= %d C i brzina = %d/% \r\n", &temp, &speed); //копирамо текст у бафер
		UART_Send((char *)buffer);	//исписујемо текст на терминал
		}

	TIM1->SR &= ~TIM_SR_UIF; 			//брисање update флега из статусног регистра тајмера 1, када ја прекид опслужен
}


void timerispisa1(void){

	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; //омогућавамо клок порта А уписивањем 1 на бит 2 APB2ENR регистра, стр. 114

	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN; //омогућавамо клок тајмера 1, стр. 114

	TIM1->DIER |= TIM_DIER_UIE;			//омогућавамо прекид уписивањем бита 1 у бит Update interrupt enable, стр. 410

	TIM1->SR = 0;						//бришемо све из статусног регистра превентивно

	// За добијање жељене брзине рада тајмера користимо следећу формулу и на основу ње уписујемо вредности у регистре
	// Timer driving frequency = 80 MHz/(l + PSC) = 80 MHz/(1+7999) = 10kHz
	// frequency = 10kHz/(1 + ARR) = 10kHz/5000 = 2Hz

	TIM1->PSC = 7999;					//подешавамо preslaler, служи да подели фреквенцију самог микроконтролера, стр. 419

	TIM1->ARR = 4999;					//auto reaload регистар, означава нам "до колико" бројимо, стр. 419

	NVIC_EnableIRQ(TIM1_UP_IRQn); 		//омогућавање прекида тајмера 1

	__enable_irq();						//омогућавање прекида

	TIM1->CR1 |= TIM_CR1_CEN;			// уписивањем 1 на бит 0 контролног регистра 1 омогућујемо бројач тајмера 1, стр. 405
}

//иницијализација тајмера за окидање АД конверзија
void adtim1(void){

	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; 	//омогућавамо клок порта А уписивањем 1 на бит 2 APB2ENR регистра, стр. 114

	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;		//омогућавамо клок тајмера 1, стр. 114

	TIM3->CR2 &= ~TIM_CR2_MMS; 				//бришемо вредност MMS битова контролог регистра 2 тајмера 3

	TIM3->CR2 |= (0b101 << TIM_CR2_MMS_Pos);//сетујемо OC2REF као тригер излаз TRGO (OC2REF=101), стр. 406

	// За добијање жељене брзине рада тајмера користимо следећу формулу и на основу ње уписујемо вредности у регистре
	// Timer driving frequency = 80 MHz/(l + PSC) = 80 MHz/(1+7999) = 10kHz
	// frequency = 10kHz/(1 + ARR) = 10kHz/1000 = 10Hz

	TIM3->PSC = 7999;						//подешавамо preslaler, служи да подели фреквенцију самог микроконтролера, стр. 419

	TIM3->ARR = 1000;						//auto reaload регистар, означава нам "до колико" бројимо, стр. 419

	TIM3->CCR2 = 50;						//ширину имуплса подешавамо уписивањем вредности у Capture/Compare регистар, вредност ће бити 1 док је вредност бројача мања од Capture/Compare регистра, стр. 421

	TIM3->CCMR1 &= ~TIM_CCMR1_OC2M; 		//Бришемо вредност Output compare 2 мода, стр. 413

	TIM3->CCMR1 |= (0b110 << TIM_CCMR1_OC2M_Pos); //Уписујемо 110 у OC2 битове регистра 1 capture/compare mode и тиме сетујемо режим рада у PWM мод 1, стр. 387

	TIM3->CCER |= TIM_CCER_CC2P;			//подешавамо поларитет Capture/Compare ->  0 = active high, capture/compare enable регистар стр. 417

	TIM3->CCER |= TIM_CCER_CC2E; 			//сетујемо Capture/Compare 2 output enable бит и тиме омогућавамо излазни сигнал на његовом унапред декларисаном пину.

	TIM3->DIER |=TIM_DIER_TIE; 				//омогућавамо тригер прекид уписивањем бита 1 у бит Trigger interrupt enable, стр. 409

	TIM3->SR &= ~TIM_SR_TIF; 				//превентивно бришемо Trigger Interrupt Flag

	TIM3->CR1 |= TIM_CR1_CEN;				//уписивањем 1 на бит 0 контролног регистра 1 омогућујемо бројач тајмера 3, стр. 405

	NVIC_EnableIRQ(TIM3_IRQn); 				//омогућавање прекида тајмера 3

	__enable_irq(); 						 //омогућавање прекида
}


